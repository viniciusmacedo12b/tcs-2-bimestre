<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reconhecedor de Dígitos por IA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            flex-direction: column;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 350px;
        }
        input[type="file"] {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: calc(100% - 22px);
            box-sizing: border-box;
        }
        button {
            padding: 15px 30px;
            font-size: 1.2em;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5pped;
            cursor: pointer;
            transition: background-color 0.3s ease;
            width: 100%;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #loading {
            margin-top: 20px;
            font-size: 1.1em;
            color: #555;
            display: none;
        }
        #fileWarning {
            color: red;
            margin-top: 10px;
            font-size: 0.9em;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Reconhecedor de Dígitos com IA</h1>
        <p>Selecione uma imagem (PNG, JPG, JPEG, GIF) para análise:</p>
        <input type="file" id="imageUpload" name="image" accept="image/png, image/jpeg, image/jpg, image/gif">
        <div id="fileWarning">Por favor, selecione um arquivo de imagem.</div>
        <button id="predictButton">Analisar Imagem</button>
        <div id="loading" style="display:none;">Aguardando imagem...</div>
        <div id="predictionResult"></div> ```
    </div>

<script>
    document.getElementById('predictButton').addEventListener('click', async () => {
        const button = document.getElementById('predictButton');
        const loadingDiv = document.getElementById('loading');
        const fileInput = document.getElementById('imageUpload');
        const fileWarning = document.getElementById('fileWarning');
        const resultDiv = document.getElementById('predictionResult'); // Adicionei este para exibir o resultado

        // Limpa mensagens anteriores
        fileWarning.style.display = 'none';
        resultDiv.textContent = ''; // Limpa o resultado anterior
        loadingDiv.textContent = 'Aguardando imagem...'; // Mensagem inicial de carregamento

        if (fileInput.files.length === 0) {
            fileWarning.style.display = 'block';
            return;
        }

        button.disabled = true;
        loadingDiv.style.display = 'block';
        loadingDiv.textContent = 'Analisando... Por favor, aguarde.'; // Atualiza mensagem de carregamento

        const formData = new FormData();
        formData.append('image', fileInput.files[0]);

        // --- INÍCIO DO CÓDIGO ATUALIZADO PARA O FETCH COM TIMEOUT E TRATAMENTO DE ERROS REFINADO ---
        const controller = new AbortController();
        // Define um timeout de 15 segundos (15000 milissegundos) para a requisição
        const TIMEOUT_DURATION = 15000; // 15 segundos
        const timeoutId = setTimeout(() => {
            controller.abort(); // Cancela a requisição se o tempo expirar
            console.error("Requisição cancelada por timeout após " + TIMEOUT_DURATION / 1000 + " segundos.");
            loadingDiv.textContent = 'Erro: A requisição demorou muito para responder. Verifique o servidor.';
            alert('Ocorreu um erro: A requisição demorou muito para responder. Verifique o servidor e sua conexão.');
        }, TIMEOUT_DURATION); // 15 segundos de timeout

        try {
            const response = await fetch('http://127.0.0.1:5001/api/predict', {
                method: 'POST',
                body: formData,
                signal: controller.signal // Associa o sinal de abort ao fetch
            });

            // Limpa o timeout assim que a resposta for recebida (mesmo que seja um erro HTTP)
            clearTimeout(timeoutId);

            if (!response.ok) { // Verifica se o status HTTP NÃO é 2xx (ex: 400, 500, 405)
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    // Tenta ler o corpo da resposta como JSON para mais detalhes
                    const errorJson = await response.json();
                    errorMessage += `, message: ${errorJson.message || JSON.stringify(errorJson)}`;
                } catch (jsonError) {
                    // Se não for JSON, lê como texto
                    const errorText = await response.text();
                    errorMessage += `, details: ${errorText}`;
                }
                console.error('Erro na resposta do servidor (HTTP status diferente de OK):', errorMessage);
                loadingDiv.textContent = `Erro do servidor: ${response.status}. Detalhes no console.`;
                alert(`Ocorreu um erro do servidor (Status: ${response.status}). ${errorMessage}`);
                return; // Sai da função, pois a resposta não foi OK
            }

            // A resposta é OK (status 2xx), então tentamos parsear como JSON
            const data = await response.json();

            if (data.success) {
                resultDiv.textContent = `Número Previsto: ${data.prediction}`;
                loadingDiv.textContent = 'Análise concluída. Verifique o arquivo "resultado_predicao.txt" para o resultado.';
                alert(`Previsão da IA: ${data.prediction}`); // Mantive o alert para feedback rápido
            } else {
                resultDiv.textContent = `Erro na predição: ${data.message || 'Erro desconhecido.'}`;
                loadingDiv.textContent = 'Ocorreu um erro durante a análise.';
                alert(`Erro na predição: ${data.message || 'Erro desconhecido.'}`);
            }

        } catch (error) {
            // Captura erros de rede (ex: servidor offline), problemas com JSON, ou o AbortError do timeout
            clearTimeout(timeoutId); // Garante que o timeout seja limpo

            if (error.name === 'AbortError') {
                // Este erro já foi tratado no setTimeout (se foi por timeout)
                console.warn("Requisição abortada (provavelmente por timeout ou pelo usuário).");
                // A mensagem para o usuário já foi definida no setTimeout
            } else if (error instanceof SyntaxError) {
                // Erro ao fazer parse do JSON (a resposta do servidor não é JSON válida ou está incompleta)
                console.error('Erro ao processar JSON da resposta (resposta não é JSON válida/completa):', error);
                loadingDiv.textContent = 'Erro: Resposta inválida/incompleta do servidor (não é JSON válida).';
                alert('Ocorreu um erro ao processar a resposta do servidor. Detalhes: Formato de JSON inválido ou incompleto.');
            } else {
                // Outros erros de rede ou genéricos
                console.error('Erro na requisição ou na rede (provavelmente servidor offline ou bloqueado):', error);
                loadingDiv.textContent = 'Erro ao conectar ao servidor ou processar resposta. Verifique o console.';
                alert('Ocorreu um erro ao tentar se comunicar com o servidor. Verifique se o servidor está rodando, se a URL da API está correta, ou se há bloqueios de firewall/antivírus. Detalhes: ' + error.message);
            }
        } finally {
            button.disabled = false;
            // loadingDiv.style.display = 'none'; // Não esconde mais, apenas muda o texto
            fileInput.value = ''; // Limpa o campo de arquivo
        }
    });
</script>